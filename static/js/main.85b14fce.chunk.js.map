{"version":3,"sources":["Node.jsx","Line.jsx","Graph.jsx","InputChange.jsx","Grid.jsx","Pathfinder.jsx","serviceWorker.js","index.js"],"names":["Node","props","dotStyle","height","width","getNodeType","nodeState","nodeType","state","isStart","isEnd","isVisited","Fragment","id","this","className","style","left","col","top","row","React","Component","Line","dijkstra","startX","startY","endX","endY","endNodeAnimate","visitedNodesInOrder","startNodeAnimate","animatedNormalNodes","graph","currentNode","distance","Infinity","previous","createGraph","closestNode","findNodeWithMinDist","startNode","endNode","push","setTimeout","document","getElementById","length","unVisitedNodes","node","nodes","right","bottom","nodesNotVisitedFromGivenNode","k","nodeInGraph","updateDist","traceAnimations","endPathAnimate","shortestPath","startPathAnimate","animatedPath","reverse","traceBack","currentMin","currentMinNode","InputChange","console","log","startRow","startCol","endRow","endCol","handleRowColChange","type","value","name","onChange","animationStarted","Grid","resetState","forEach","nodeAnimation","clearTimeout","resetGrid","validInput","parseInt","edgeNode","normalNode","visualize","animatedNodes","window","alert","createGrid","grid","event","setState","target","onClick","Pathfinder","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.85b14fce.chunk.js","sourcesContent":["import React from \"react\"\nimport \"./Node.css\"\n\nconst marginFactor = 45\n\nclass Node extends React.Component {\n    constructor(props) {\n        super(props)\n         this.state = {\n            isVisited: this.props.isVisited,\n            isStart: this.props.isStart,\n            isEnd: this.props.isEnd,\n        }\n    }\n\n    dotStyle = [\n        { height: 25 },\n        { width: 25 },\n    ]\n\n    getNodeType = (nodeState) => {\n        let nodeType = \"\"\n        if (this.state.isStart) {\n            nodeType = \"startNode\"\n        }\n        else if (this.state.isEnd) {\n            nodeType = \"endNode\"\n        }\n        else if (this.state.isVisited) {\n            nodeType = \"visitedNode\"\n        }\n        return nodeType\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <span id={this.props.id}\n                    className={`dot ${this.getNodeType()}`}\n                    style={{\n                        left: this.props.col * marginFactor,\n                        top: this.props.row * marginFactor\n                    }}\n                >\n                </span>\n            </React.Fragment>\n        )\n    }\n}\nexport default Node ","import React from \"react\"\nimport \"./Line.css\"\n\nconst marginFactor = 45\n\nclass Line extends React.Component {\n    render() {\n        const { row, col } = this.props\n        return (\n            <span\n                className=\"line\"\n                style={{\n                    left: col * marginFactor + 15,\n                    top: row * marginFactor + 15\n                }}\n            />\n        )\n    }\n}\n\nexport default Line ","function createGraph(width, height) {\n    let graph = [[]]\n    for (let col = 0; col < width; col++) {\n        graph[col] = []\n        for (let row = 0; row < height; row++) {\n            graph[col][row] = []\n            let currentNode = graph[col][row]\n            currentNode.row = row\n            currentNode.col = col\n            currentNode.isVisited = false\n            currentNode.distance = Infinity\n            currentNode.previous = null\n        }\n    }\n    return graph\n}\n\nfunction nodesNotVisitedFromGivenNode(graph, node, width, height) {\n    let nodes = []\n\n    if (node.row - 1 >= 0 && node.col >= 0) {\n        let top = graph[node.col][node.row - 1]\n        if (!top.isVisited) nodes.push(top)\n    }\n    if (node.col - 1 >= 0 && node.row >= 0) {\n        let left = graph[node.col - 1][node.row]\n        if (!left.isVisited) nodes.push(left)\n    }\n    if (node.col + 1 < width && node.row >= 0) {\n        let right = graph[node.col + 1][node.row]\n        if (!right.isVisited) nodes.push(right)\n    }\n    if (node.col >= 0 && node.row + 1 < height) {\n        let bottom = graph[node.col][node.row + 1]\n        if (!bottom.isVisited) nodes.push(bottom)\n    }\n    return nodes\n}\n\nexport function dijkstra(width, height, startX, startY, endX, endY) {\n    let visitedNodesInOrder = []\n    let startNodeAnimate = 0\n    let animatedNormalNodes = []\n    let endNodeAnimate = 0\n    let graph = createGraph(width, height)\n    graph[startX][startY].distance = 0\n\n    let closestNode = findNodeWithMinDist(graph, width, height)\n    let startNode = closestNode\n    let endNode = graph[endX][endY]\n\n    while (closestNode.row !== endY || closestNode.col !== endX) {\n        closestNode.isVisited = true\n        visitedNodesInOrder.push(closestNode)\n\n        let { row, col } = closestNode\n\n        if (closestNode === startNode) {\n            startNodeAnimate = setTimeout(() => {\n                document.getElementById(`node-${row}-${col}`)\n                    .className = \"dot startNodeAnimate\"\n            }, (visitedNodesInOrder.length) * 100)\n        }\n        if (closestNode !== startNode) {\n            animatedNormalNodes.push(\n                setTimeout(() => {\n                    document.getElementById(`node-${row}-${col}`)\n                        .className = \"dot visitedNode\"\n                }, (visitedNodesInOrder.length - 1) * 100)\n            )\n        }\n\n        let unVisitedNodes = nodesNotVisitedFromGivenNode(graph, closestNode, width, height)\n        updateDist(graph, unVisitedNodes, closestNode)\n\n        closestNode = findNodeWithMinDist(graph, width, height)\n    }\n    endNodeAnimate = setTimeout(() => {\n        document.getElementById(`node-${endNode.row}-${endNode.col}`)\n            .className = \"dot endNodeAnimate\"\n    }, (visitedNodesInOrder.length) * 100)\n\n    visitedNodesInOrder.push(closestNode)\n\n    let traceAnimations = traceBack(graph, startNode, endNode, visitedNodesInOrder)\n\n    return [startNodeAnimate, animatedNormalNodes, endNodeAnimate, traceAnimations]\n}\n\nfunction updateDist(graph, unVisitedNodes, closestNode) {\n    for (let k = 0; k < unVisitedNodes.length; k++) {\n        let node = unVisitedNodes[k]\n        let nodeInGraph = graph[node.col][node.row]\n\n        if (nodeInGraph.distance > closestNode.distance + 1) {\n            nodeInGraph.distance = closestNode.distance + 1\n            nodeInGraph.previous = closestNode\n        }\n    }\n}\n\nfunction findNodeWithMinDist(graph, width, height) {\n    let currentMin = Infinity\n    let currentMinNode = null\n    for (let col = 0; col < width; col++) {\n        for (let row = 0; row < height; row++) {\n            if (graph[col][row].isVisited === false &&\n                graph[col][row].distance < currentMin) {\n                currentMin = graph[col][row].distance\n                currentMinNode = graph[col][row]\n            }\n        }\n    }\n    return currentMinNode\n}\n\nfunction traceBack(graph, startNode, endNode, visitedNodesInOrder) {\n    let shortestPath = []\n    let startPathAnimate = 0\n    let animatedPath = []\n    let endPathAnimate = 0\n    let currentNode = graph[endNode.col][endNode.row]\n\n    while (currentNode.row !== startNode.row || currentNode.col !== startNode.col) {\n        shortestPath.push(currentNode)\n        currentNode = currentNode.previous\n    }\n    shortestPath.push(currentNode)\n    shortestPath.reverse()\n\n    // Sets starting and ending node to regular nodes and it can re-animate\n    setTimeout(() => {\n        document.getElementById(`node-${startNode.row}-${startNode.col}`)\n            .className = \"dot startNode\"\n        document.getElementById(`node-${endNode.row}-${endNode.col}`)\n            .className = \"dot endNode\"\n    }, (visitedNodesInOrder.length) * 101)\n\n    for (let k = 0; k < shortestPath.length; k++) {\n        let currentNode = shortestPath[k]\n        const { row, col } = currentNode\n\n        if (currentNode === startNode) {\n            startPathAnimate = setTimeout(() => {\n                document.getElementById(`node-${row}-${col}`)\n                    .className = \"dot startNodeAnimate\"\n            }, (visitedNodesInOrder.length + 1) * 101)\n        }\n\n        if (currentNode !== startNode && currentNode !== endNode) {\n            animatedPath.push(\n                setTimeout(() => {\n                    document.getElementById(`node-${row}-${col}`)\n                        .className = \"dot shortestPathNode\"\n                }, (visitedNodesInOrder.length + (k + 1)) * 101)\n            )\n        }\n    }\n    endPathAnimate = setTimeout(() => {\n        document.getElementById(`node-${endNode.row}-${endNode.col}`)\n            .className = \"dot endNodeAnimate\"\n    }, (visitedNodesInOrder.length + shortestPath.length + 1) * 101)\n\n    return [startPathAnimate, animatedPath, endPathAnimate]\n}\n","import React from \"react\"\nimport \"./InputChange.css\"\n\nfunction InputChange(props) {\n    console.log(\"this.props: \", props)\n    const { startRow, startCol, endRow, endCol, handleRowColChange } = props\n    return (<footer>\n        <label className=\"startRowText\">\n            {\"Start Node Row:  \"}\n            <input type=\"text\"\n                value={startRow}\n                name=\"startRow\"\n                onChange={handleRowColChange} />\n\n        </label>\n\n        <label className=\"startRowText startColText\">\n            {\"Start Node Column:  \"}\n            <input type=\"text\"\n                value={startCol}\n                name=\"startCol\"\n                onChange={handleRowColChange}\n            />\n        </label>\n        <label className=\"endRowText\">\n            {\"End Node Row:  \"}\n            <input type=\"text\"\n                value={endRow}\n                name=\"endRow\"\n                onChange={handleRowColChange}\n            />\n        </label>\n\n        <label className=\"endRowText endColText\">\n            {\"End Node Column:  \"}\n            <input type=\"text\"\n                value={endCol}\n                name=\"endCol\"\n                onChange={handleRowColChange}\n            />\n        </label>\n    </footer>)\n}\n\nexport default InputChange","import React from 'react'\nimport Node from './Node'\nimport \"./Grid.css\"\nimport Line from \"./Line\"\nimport { dijkstra } from \"./Graph\"\nimport InputChange from \"./InputChange\"\n\nconst width = 30\nconst height = 10\n\nconst defaultStartX = 2\nconst defaultStartY = 2\n\nconst defaultEndX = 22\nconst defaultEndY = 6\n\nlet startNodeAnimate = 0\nlet animatedNormalNodes = []\nlet endNodeAnimate = 0\nlet startPathAnimate = 0\nlet animatedPath = []\nlet endPathAnimate = 0\nlet animationStarted = false\n\nclass Grid extends React.Component {\n    constructor() {\n        super()\n        this.state = {\n            startRow: defaultStartY,\n            startCol: defaultStartX,\n            endRow: defaultEndY,\n            endCol: defaultEndX,\n            grid: null,\n        }\n    }\n\n    componentDidMount() {\n        this.setState({\n            grid: this.createGrid()\n        })\n    }\n\n    resetState = () => {\n        let { startRow, startCol, endRow, endCol } = this.state\n\n        animatedNormalNodes.forEach((nodeAnimation) => clearTimeout(nodeAnimation))\n        animatedPath.forEach((nodeAnimation) => clearTimeout(nodeAnimation))\n\n        clearTimeout(startNodeAnimate)\n        clearTimeout(endNodeAnimate)\n        clearTimeout(startPathAnimate)\n        clearTimeout(endPathAnimate)\n\n        this.resetGrid(startRow, startCol, endRow, endCol)\n\n        animationStarted = false\n    }\n\n    validInput = () => {\n        const { startRow, startCol, endRow, endCol } = this.state\n        let validInput = true\n        if (document.getElementById(`node-${startRow - 1}-${startCol - 1}`) === null) {\n            validInput = false\n        }\n        if (document.getElementById(`node-${endRow - 1}-${endCol - 1}`) === null) {\n            validInput = false\n        }\n        return validInput\n    }\n\n    resetGrid = (startRow, startCol, endRow, endCol) => {\n\n        let validInput = false\n        if (this.validInput()) {\n            startRow = parseInt(startRow - 1)\n            startCol = parseInt(startCol - 1)\n            endRow = parseInt(endRow - 1)\n            endCol = parseInt(endCol - 1)\n            validInput = true\n        }\n\n        for (let col = 0; col < width && validInput; col++) {\n            for (let row = 0; row < height && validInput; row++) {\n                if (row === startRow && col === startCol) {\n                    document.getElementById(`node-${row}-${col}`)\n                        .className = \"dot startNode\"\n                }\n                else if (row === endRow && col === endCol) {\n                    document.getElementById(`node-${row}-${col}`)\n                        .className = \"dot endNode\"\n                }\n                else {\n                    console.log(\"NODE IS: \", row, \",\", col)\n                    document.getElementById(`node-${row}-${col}`).className = \"dot\"\n                }\n            }\n        }\n    }\n\n    edgeNode = (col, row) => {\n\n        const { startRow, startCol, endRow, endCol } = this.state\n        if (col === startCol - 1 && row === startRow - 1) {\n            return <div>\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col}\n                    isStart={true} />\n            </div>\n        }\n        else if (col === endCol - 1 && row === endRow - 1) {\n            return <div>\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col}\n                    isEnd={true} />\n            </div>\n        }\n        else {\n            return <div>\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col} />\n            </div>\n        }\n    }\n\n    normalNode = (col, row) => {\n        const { startRow, startCol, endRow, endCol } = this.state\n        if (col === startCol - 1 && row === startRow - 1) {\n            return <div>\n                <Line row={row} col={col} />\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col}\n                    isStart={true} />\n            </div>\n        }\n        else if (col === endCol - 1 && row === endRow - 1) {\n            return <div>\n                <Line row={row} col={col} />\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col}\n                    isEnd={true} />\n            </div>\n        }\n        else {\n            return <div>\n                <Line row={row} col={col} />\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col} />\n            </div>\n        }\n    }\n\n    visualize = () => {\n        const { startRow, startCol, endRow, endCol } = this.state\n\n        if (!animationStarted && this.validInput()) {\n            animationStarted = true\n            let animatedNodes = dijkstra(width, height, startCol - 1,\n                startRow - 1, endCol - 1, endRow - 1)\n\n            startNodeAnimate = animatedNodes[0]\n            animatedNormalNodes = animatedNodes[1]\n            endNodeAnimate = animatedNodes[2]\n            startPathAnimate = animatedNodes[3][0]\n            animatedPath = animatedNodes[3][1]\n            endPathAnimate = animatedNodes[3][2]\n        }\n        else if (!this.validInput()) {\n            window.alert(\"Invaid input!\\nRow Range: [1,10]\\nColumn Range: [1,30]\")\n        }\n    }\n\n    createGrid = () => {\n        let grid = [[]]\n        for (let col = 0; col < width; col++) {\n            grid[col] = []\n            for (let row = 0; row < height; row++) {\n                if (col === width - 1 || row === height - 1) {\n                    grid[col][row] = this.edgeNode(col, row)\n                }\n                else {\n                    grid[col][row] = this.normalNode(col, row)\n                }\n            }\n        }\n        return grid\n    }\n\n    handleRowColChange = (event) => {\n        this.setState({\n            [event.target.name]: event.target.value,\n        }, () => this.resetState())\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <header\n                    className=\"header\">\n                    Dijkstra's Shortest Path Algorithm Visualization\n                </header>\n                <div>\n                    {this.state.grid}\n                </div>\n\n                <button className=\"startButton\"\n                    onClick={this.visualize}>\n                    Start Visualization\n                </button>\n\n                <button className=\"resetButton\"\n                    onClick={this.resetState}>\n                    Reset\n                </button>\n\n                <InputChange\n                    startCol={this.state.startCol}\n                    startRow={this.state.startRow}\n                    endCol={this.state.endCol}\n                    endRow={this.state.endRow}\n                    handleRowColChange={this.handleRowColChange}\n                />\n            </React.Fragment>\n        )\n    }\n}\n\nexport default Grid ","import React from 'react'\nimport Grid from \"./Grid\"\n\nclass Pathfinder extends React.Component {\n    render() {\n        return (\n            <div>\n                <Grid> </Grid>\n                \n            </div>\n        )\n    }\n}\n\nexport default Pathfinder","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Pathfinder from \"./Pathfinder\"\nimport \"bootstrap/dist/css/bootstrap.css\"\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <Pathfinder />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}