{"version":3,"sources":["Node.jsx","Line.jsx","Graph.jsx","Grid.jsx","Pathfinder.jsx","serviceWorker.js","index.js"],"names":["Node","props","dotStyle","height","width","getNodeType","nodeState","nodeType","state","isStart","isEnd","isVisited","Fragment","id","this","className","style","left","row","top","col","React","Component","Line","dijkstra","startX","startY","endX","endY","endNodeAnimate","visitedNodesInOrder","startNodeAnimate","animatedNormalNodes","graph","currentNode","distance","Infinity","previous","createGraph","closestNode","findNodeWithMinDist","startNode","endNode","push","setTimeout","document","getElementById","length","unVisitedNodes","node","nodes","right","bottom","nodesNotVisitedFromGivenNode","k","nodeInGraph","updateDist","traceAnimations","endPathAnimate","shortestPath","startPathAnimate","animatedPath","reverse","traceBack","currentMin","currentMinNode","animationStarted","Grid","resetState","forEach","nodeAnimation","clearTimeout","edgeNode","normalNode","visualize","animatedNodes","createGrid","grid","onClick","Pathfinder","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.a2f18ec5.chunk.js","sourcesContent":["import React from \"react\"\nimport \"./Node.css\"\n\nconst marginFactor = 45\n\nclass Node extends React.Component {\n    constructor(props) {\n        super(props)\n         this.state = {\n            isVisited: this.props.isVisited,\n            isStart: this.props.isStart,\n            isEnd: this.props.isEnd,\n        }\n    }\n\n    dotStyle = [\n        { height: 25 },\n        { width: 25 },\n    ]\n\n    getNodeType = (nodeState) => {\n        let nodeType = \"\"\n        if (this.state.isStart) {\n            nodeType = \"startNode\"\n        }\n        else if (this.state.isEnd) {\n            nodeType = \"endNode\"\n        }\n        else if (this.state.isVisited) {\n            nodeType = \"visitedNode\"\n        }\n        return nodeType\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <span id={this.props.id}\n                    className={`dot ${this.getNodeType()}`}\n                    style={{\n                        left: this.props.row * marginFactor,\n                        top: this.props.col * marginFactor\n                    }}\n                >\n                </span>\n            </React.Fragment>\n        )\n    }\n}\nexport default Node ","import React from \"react\"\nimport \"./Line.css\"\n\nconst marginFactor = 45\n\nclass Line extends React.Component {\n    render() {\n        const { row, col } = this.props\n        return (\n            <span\n                className=\"line\"\n                style={{\n                    left: row * marginFactor + 12,\n                    top: col * marginFactor + 13\n                }}\n            />\n        )\n    }\n}\n\nexport default Line ","function createGraph(width, height) {\n    let graph = [[]]\n    for (let row = 0; row < width; row++) {\n        graph[row] = []\n        for (let col = 0; col < height; col++) {\n            graph[row][col] = []\n            let currentNode = graph[row][col]\n            currentNode.row = row\n            currentNode.col = col\n            currentNode.isVisited = false\n            currentNode.distance = Infinity\n            currentNode.previous = null\n        }\n    }\n    return graph\n}\n\nfunction nodesNotVisitedFromGivenNode(graph, node, width, height) {\n    let nodes = []\n\n    if (node.col - 1 >= 0 && node.row >= 0) {\n        let top = graph[node.row][node.col - 1]\n        if (!top.isVisited) nodes.push(top)\n    }\n    if (node.row - 1 >= 0 && node.col >= 0) {\n        let left = graph[node.row - 1][node.col]\n        if (!left.isVisited) nodes.push(left)\n    }\n    if (node.row + 1 < width && node.col >= 0) {\n        let right = graph[node.row + 1][node.col]\n        if (!right.isVisited) nodes.push(right)\n    }\n    if (node.row >= 0 && node.col + 1 < height) {\n        let bottom = graph[node.row][node.col + 1]\n        if (!bottom.isVisited) nodes.push(bottom)\n    }\n    return nodes\n}\n\nexport function dijkstra(width, height, startX, startY, endX, endY) {\n    let visitedNodesInOrder = []\n    let startNodeAnimate = 0\n    let animatedNormalNodes = []\n    let endNodeAnimate = 0\n    let graph = createGraph(width, height)\n    graph[startX][startY].distance = 0\n\n    let closestNode = findNodeWithMinDist(graph, width, height)\n    let startNode = closestNode\n    let endNode = graph[endX][endY]\n\n    while (closestNode.row !== endX || closestNode.col !== endY) {\n        closestNode.isVisited = true\n        visitedNodesInOrder.push(closestNode)\n\n        let { row, col } = closestNode\n\n        if (closestNode === startNode) {\n            startNodeAnimate = setTimeout(() => {\n                document.getElementById(`node-${row}-${col}`)\n                    .className = \"dot startNodeAnimate\"\n            }, (visitedNodesInOrder.length) * 100)\n        }\n        if (closestNode !== startNode) {\n            animatedNormalNodes.push(\n                setTimeout(() => {\n                    document.getElementById(`node-${row}-${col}`)\n                        .className = \"dot visitedNode\"\n                }, (visitedNodesInOrder.length - 1) * 100)\n            )\n        }\n\n        let unVisitedNodes = nodesNotVisitedFromGivenNode(graph, closestNode, width, height)\n        updateDist(graph, unVisitedNodes, closestNode)\n\n        closestNode = findNodeWithMinDist(graph, width, height)\n    }\n\n    endNodeAnimate = setTimeout(() => {\n        document.getElementById(`node-${endNode.row}-${endNode.col}`)\n            .className = \"dot endNodeAnimate\"\n    }, (visitedNodesInOrder.length) * 100)\n\n    visitedNodesInOrder.push(closestNode)\n    let traceAnimations = traceBack(graph, startNode, endNode, visitedNodesInOrder)\n\n    return [startNodeAnimate, animatedNormalNodes, endNodeAnimate, traceAnimations]\n}\n\nfunction updateDist(graph, unVisitedNodes, closestNode) {\n    for (let k = 0; k < unVisitedNodes.length; k++) {\n        let node = unVisitedNodes[k]\n        let nodeInGraph = graph[node.row][node.col]\n\n        if (nodeInGraph.distance > closestNode.distance + 1) {\n            nodeInGraph.distance = closestNode.distance + 1\n            nodeInGraph.previous = closestNode\n        }\n    }\n}\n\nfunction findNodeWithMinDist(graph, width, height) {\n    let currentMin = Infinity\n    let currentMinNode = null\n    for (let row = 0; row < width; row++) {\n        for (let col = 0; col < height; col++) {\n            if (graph[row][col].isVisited === false &&\n                graph[row][col].distance < currentMin) {\n                currentMin = graph[row][col].distance\n                currentMinNode = graph[row][col]\n            }\n        }\n    }\n    return currentMinNode\n}\n\nfunction traceBack(graph, startNode, endNode, visitedNodesInOrder) {\n    let shortestPath = []\n    let startPathAnimate = 0\n    let animatedPath = []\n    let endPathAnimate = 0\n    let currentNode = graph[endNode.row][endNode.col]\n\n    while (currentNode.row !== startNode.row || currentNode.col !== startNode.col) {\n        shortestPath.push(currentNode)\n        currentNode = currentNode.previous\n    }\n    shortestPath.push(currentNode)\n    shortestPath.reverse()\n\n    // Sets starting and ending node to regular nodes and it can re-animate\n    setTimeout(() => {\n        document.getElementById(`node-${startNode.row}-${startNode.col}`)\n            .className = \"dot startNode\"\n        document.getElementById(`node-${endNode.row}-${endNode.col}`)\n            .className = \"dot endNode\"\n    }, (visitedNodesInOrder.length) * 101)\n\n    for (let k = 0; k < shortestPath.length; k++) {\n        let currentNode = shortestPath[k]\n        const { row, col } = currentNode\n\n        if (currentNode === startNode) {\n            startPathAnimate = setTimeout(() => {\n                document.getElementById(`node-${row}-${col}`)\n                    .className = \"dot startNodeAnimate\"\n            }, (visitedNodesInOrder.length + 1) * 101)\n        }\n\n        if (currentNode !== startNode && currentNode !== endNode) {\n            animatedPath.push(\n                setTimeout(() => {\n                    document.getElementById(`node-${row}-${col}`)\n                        .className = \"dot shortestPathNode\"\n                }, (visitedNodesInOrder.length + (k + 1)) * 101)\n            )\n        }\n    }\n    endPathAnimate = setTimeout(() => {\n        document.getElementById(`node-${endNode.row}-${endNode.col}`)\n            .className = \"dot endNodeAnimate\"\n    }, (visitedNodesInOrder.length + shortestPath.length + 1) * 101)\n\n    return [startPathAnimate, animatedPath, endPathAnimate]\n}\n","import React from 'react'\nimport Node from './Node'\nimport \"./Grid.css\"\nimport Line from \"./Line\"\nimport { dijkstra } from \"./Graph\"\n\nconst width = 30\nconst height = 10\n\nconst startX = 2\nconst startY = 2\n\nconst endX = 22\nconst endY = 6\n\nlet startNodeAnimate = 0\nlet animatedNormalNodes = []\nlet endNodeAnimate = 0\nlet startPathAnimate = 0\nlet animatedPath = []\nlet endPathAnimate = 0\nlet animationStarted = false\n\nclass Grid extends React.Component {\n    constructor() {\n        super()\n        this.state = {\n            grid: this.createGrid()\n        }\n    }\n\n    resetState = () => {\n        \n        animatedNormalNodes.forEach((nodeAnimation) => clearTimeout(nodeAnimation))\n        animatedPath.forEach((nodeAnimation) => clearTimeout(nodeAnimation))\n\n        clearTimeout(startNodeAnimate)\n        clearTimeout(endNodeAnimate)\n        clearTimeout(startPathAnimate)\n        clearTimeout(endPathAnimate)\n\n        for (let row = 0; row < width; row++) {\n            for (let col = 0; col < height; col++) {\n                if (row === startX && col === startY) {\n                    document.getElementById(`node-${row}-${col}`)\n                        .className = \"dot startNode\"\n                }\n                else if (row === endX && col === endY) {\n                    document.getElementById(`node-${row}-${col}`)\n                        .className = \"dot endNode\"\n                }\n                else {\n                    document.getElementById(`node-${row}-${col}`)\n                        .className = \"dot\"\n                }\n            }\n        }\n        animationStarted = false\n    }\n\n    edgeNode = (row, col) => {\n        if (col === startY && row === startX) {\n            return <div>\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col}\n                    isStart={true} />\n            </div>\n        }\n        else if (col === endY && row === endX) {\n            return <div>\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col}\n                    isEnd={true} />\n            </div>\n        }\n        else {\n            return <div>\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col} />\n            </div>\n        }\n    }\n\n    normalNode = (row, col) => {\n        if (col === startY && row === startX) {\n            return <div>\n                <Line row={row} col={col} />\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col}\n                    isStart={true} />\n            </div>\n        }\n        else if (col === endY && row === endX) {\n            return <div>\n                <Line row={row} col={col} />\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col}\n                    isEnd={true} />\n            </div>\n        }\n        else {\n            return <div>\n                <Line row={row} col={col} />\n                <Node id={`node-${row}-${col}`}\n                    distance={Infinity}\n                    previous={null}\n                    row={row}\n                    col={col} />\n            </div>\n        }\n    }\n\n    visualize = () => {\n        if (!animationStarted) {\n            animationStarted = true \n            let animatedNodes = dijkstra(width, height, startX, startY, endX, endY)\n            startNodeAnimate = animatedNodes[0]\n            animatedNormalNodes = animatedNodes[1]\n            endNodeAnimate = animatedNodes[2]\n            startPathAnimate = animatedNodes[3][0]\n            animatedPath = animatedNodes[3][1]\n            endPathAnimate = animatedNodes[3][2]\n        }\n    }\n\n    createGrid = () => {\n        let grid = [[]]\n        for (let row = 0; row < width; row++) {\n            grid[row] = []\n            for (let col = 0; col < height; col++) {\n\n                if (col === height - 1 || row === width - 1) {\n                    grid[row][col] = this.edgeNode(row, col)\n                }\n                else {\n                    grid[row][col] = this.normalNode(row, col)\n                }\n            }\n        }\n        return grid\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <header\n                    className=\"header\">\n                    Dijkstra's Shortest Path Algorithm Visualization\n                </header>\n                <div>\n                    {this.state.grid}\n                </div>\n\n                <button className=\"startButton\"\n                    onClick={this.visualize}>\n                    Start Visualization\n                </button>\n\n                <button className=\"resetButton\"\n                    onClick={this.resetState}>\n                    Reset\n                </button>\n\n            </React.Fragment>\n        )\n    }\n}\n\nexport default Grid ","import React from 'react'\nimport Grid from \"./Grid\"\n\nclass Pathfinder extends React.Component {\n    render() {\n        return (\n            <div>\n                <Grid> </Grid>\n            </div>\n        )\n    }\n}\n\nexport default Pathfinder","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Pathfinder from \"./Pathfinder\"\nimport \"bootstrap/dist/css/bootstrap.css\"\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <Pathfinder />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}